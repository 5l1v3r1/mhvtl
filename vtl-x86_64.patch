diff -uN vtl-0.12/dump_tape.c vtl-0.12-x86_64/dump_tape.c
--- vtl-0.12/dump_tape.c	2006-08-06 17:58:44.000000000 +1000
+++ vtl-0.12-x86_64/dump_tape.c	2006-08-31 11:35:28.000000000 +1000
@@ -101,7 +101,7 @@
 skip_to_next_header(int datafile, char * sense_flg) {
 	loff_t nread;
 
-	if(current_position.next_blk != lseek64(datafile, current_position.next_blk, SEEK_SET)) {
+	if(current_position.next_blk != lseek(datafile, current_position.next_blk, SEEK_SET)) {
 		printf("Error reading datafile while forward SPACEing!!\n");
 		return -1;
 	}
@@ -153,7 +153,7 @@
 
 	printf("Data file is : %s\n", dataFile);
 
-	if((ofp = open64(dataFile, O_RDWR)) == -1) {
+	if((ofp = open(dataFile, O_RDWR)) == -1) {
 		fprintf(stderr, "%s, ", dataFile);
 		perror("Could not open");
 		exit(1);
Common subdirectories: vtl-0.12/kernel-driver and vtl-0.12-x86_64/kernel-driver
diff -uN vtl-0.12/mktape.c vtl-0.12-x86_64/mktape.c
--- vtl-0.12/mktape.c	2006-08-06 17:58:44.000000000 +1000
+++ vtl-0.12-x86_64/mktape.c	2006-08-31 11:35:37.000000000 +1000
@@ -167,7 +167,7 @@
 	memset(&h, 0, sizeof(h));
 	h.blk_type = B_EOD;
 	h.blk_number = 0;
-	h.curr_blk = lseek64(file, 0, SEEK_CUR);
+	h.curr_blk = lseek(file, 0, SEEK_CUR);
 	h.prev_blk = 0;
 	h.next_blk = h.curr_blk;
 
diff -uN vtl-0.12/vtltape.c vtl-0.12-x86_64/vtltape.c
--- vtl-0.12/vtltape.c	2006-08-30 16:35:01.000000000 +1000
+++ vtl-0.12-x86_64/vtltape.c	2006-08-31 11:39:42.000000000 +1000
@@ -359,14 +359,14 @@
 		break;
 	}
 	if(h->blk_type == B_BOT)
-	     printf("(%d), Tape capacity %d, prev %lld, curr %lld, next %lld\n",
+	     printf("(%d), Tape capacity %d, prev %ld, curr %ld, next %ld\n",
 			h->blk_type,
 			h->blk_size,
 			h->prev_blk,
 			h->curr_blk,
 			h->next_blk);
 	else
-	     printf("(%d), sz %d, prev %lld, cur %lld, next %lld\n",
+	     printf("(%d), sz %d, prev %ld, cur %ld, next %ld\n",
 			h->blk_type,
 			h->blk_size,
 			h->prev_blk,
@@ -416,7 +416,7 @@
 loff_t
 position_to_curr_header(u8 * sense_flg) {
 
-	return (lseek64(datafile, c_pos.curr_blk, SEEK_SET));
+	return (lseek(datafile, c_pos.curr_blk, SEEK_SET));
 }
 
 int
@@ -431,7 +431,7 @@
 		return -1;
 	}
 
-	if(c_pos.next_blk != lseek64(datafile, c_pos.next_blk, SEEK_SET)) {
+	if(c_pos.next_blk != lseek(datafile, c_pos.next_blk, SEEK_SET)) {
 		mkSenseBuf(MEDIUM_ERROR,E_SEQUENTIAL_POSITION_ERR,sense_flg);
 		syslog(LOG_DAEMON|LOG_WARNING,
 					"Unable to seek to next block header");
@@ -470,9 +470,9 @@
 	// Position to previous header
 	if(debug) {
 		printf("skip_to_prev_header()\n");
-		printf("Positioning to c_pos.prev_blk: %lld\n", c_pos.prev_blk);
+		printf("Positioning to c_pos.prev_blk: %ld\n", c_pos.prev_blk);
 	}
-	if(c_pos.prev_blk != lseek64(datafile, c_pos.prev_blk, SEEK_SET)) {
+	if(c_pos.prev_blk != lseek(datafile, c_pos.prev_blk, SEEK_SET)) {
 		mkSenseBuf(MEDIUM_ERROR, E_MEDIUM_FORMAT_CORRUPT, sense_flg);
 		if(verbose)
 			syslog(LOG_DAEMON|LOG_WARNING,
@@ -482,7 +482,7 @@
 	}
 	// Read in header
 	if(debug)
-		printf("Reading in header: %d bytes\n", sizeof(c_pos));
+		printf("Reading in header: %ld bytes\n", sizeof(c_pos));
 
 	nread = read_header(&c_pos, sizeof(c_pos), sense_flg);
 	if(nread == 0) {
@@ -512,7 +512,7 @@
 		return -1;
 	}
 	DEBC(
-	 printf("Now rewinding over header just read in: curr_position: %lld\n",
+	 printf("Now rewinding over header just read in: curr_position: %ld\n",
 					c_pos.curr_blk);
 		print_header(&c_pos);
 	) ; // END debug macro
@@ -532,7 +532,7 @@
 	h.blk_type = type;	// Header type
 	h.blk_size = size;	// Size of uncompressed data
 	h.disk_blk_size = comp_size; // For when I do compression..
-	h.curr_blk = lseek64(datafile, 0, SEEK_CUR); // Update current position
+	h.curr_blk = lseek(datafile, 0, SEEK_CUR); // Update current position
 	h.blk_number = c_pos.blk_number;
 
 	// If we are writing a new EOD marker,
@@ -555,12 +555,12 @@
 		h.blk_number = c_pos.blk_number + 1;
 	} else {
 		DEBC(
-	       printf("Position error trying to write header, curr_pos: %lld\n",
+	       printf("Position error trying to write header, curr_pos: %ld\n",
 								h.curr_blk);
 			print_header(&c_pos);
 		) ; // END debug macro
 		syslog(LOG_DAEMON|LOG_ERR,
-		"Fatal: Position error blk No: %lld, Pos: %lld, Exp: %lld",
+		"Fatal: Position error blk No: %ld, Pos: %ld, Exp: %ld",
 				h.blk_number, h.curr_blk, c_pos.curr_blk);
 		mkSenseBuf(MEDIUM_ERROR,E_SEQUENTIAL_POSITION_ERR,sense_flg);
 		return 0;
@@ -575,11 +575,11 @@
 		mkSenseBuf(MEDIUM_ERROR, E_WRITE_ERROR, sense_flg);
 		if(debug) {
 			if(nwrite < 0) perror("header write failed");
-			printf("Error writing %d header, pos: %lld\n",
+			printf("Error writing %d header, pos: %ld\n",
 							type, h.curr_blk);
 		} else {
 			syslog(LOG_DAEMON|LOG_ERR,
-				"Write failure, pos: %lld: %m", h.curr_blk);
+				"Write failure, pos: %ld: %m", h.curr_blk);
 		}
 		return nwrite;
 	}
@@ -938,7 +938,7 @@
 			syslog(LOG_DAEMON|LOG_INFO,"LOG SENSE: TapeAlert page");
 		if(verbose > 1)
 			syslog(LOG_DAEMON|LOG_INFO,
-					" Returning TapeAlert flags: 0x%llx",
+					" Returning TapeAlert flags: 0x%lx",
 					ntohll(seqAccessDevice.TapeAlert));
 			
 		TapeAlert.pcode_head.len = htons(sizeof(TapeAlert) -
@@ -1117,7 +1117,7 @@
 		break;
 	case B_COMPRESSED_DATA:
 		// If we are positioned at beginning of header, read it in.
-		if(c_pos.curr_blk == lseek64(datafile, 0, SEEK_CUR)) {
+		if(c_pos.curr_blk == lseek(datafile, 0, SEEK_CUR)) {
 			nread = read_header(&c_pos, sizeof(c_pos), sense_flg);
 			if(nread == 0) {	// Error
 				syslog(LOG_DAEMON|LOG_ERR,
@@ -1178,7 +1178,7 @@
 		break;
 	case B_UNCOMPRESS_DATA:
 		// If we are positioned at beginning of header, read it in.
-		if(c_pos.curr_blk == lseek64(datafile, 0, SEEK_CUR)) {
+		if(c_pos.curr_blk == lseek(datafile, 0, SEEK_CUR)) {
 			nread = read_header(&c_pos, sizeof(c_pos), sense_flg);
 			if(nread == 0) {	// Error
 				syslog(LOG_DAEMON|LOG_ERR, "%m");
@@ -1207,7 +1207,7 @@
 	default:
 		if(verbose)
 		  syslog(LOG_DAEMON|LOG_ERR,
-			"Unknown blk header at offset %lld - Abort read cmd",
+			"Unknown blk header at offset %ld - Abort read cmd",
 							c_pos.curr_blk);
 		mkSenseBuf(MEDIUM_ERROR, E_UNRECOVERED_READ, sense_flg);
 		return 0;
@@ -1301,7 +1301,7 @@
 rawRewind(u8 *sense_flg) {
 
 	// Start at beginning of datafile..
-	lseek64(datafile, 0L, SEEK_SET);
+	lseek(datafile, 0L, SEEK_SET);
 
 	/*
 	 * Read header..
@@ -1439,7 +1439,7 @@
 	loff_t nwrite = 0;
 
 	// Start at beginning of datafile..
-	lseek64(datafile, 0L, SEEK_SET);
+	lseek(datafile, 0L, SEEK_SET);
 
 	/* Update the c_pos data struct.
 	 * If this is not the BOT header we are in trouble
@@ -1567,7 +1567,7 @@
 		 */
 		if(verbose)
 			syslog(LOG_DAEMON|LOG_INFO,
-			"Current blk: %lld, seek: %d",c_pos.blk_number,count);
+			"Current blk: %ld, seek: %d",c_pos.blk_number,count);
 		if(((u32)(count - c_pos.blk_number) > count) &&
 						(count < c_pos.blk_number)) {
 			respRewind(sense_flg);
@@ -1935,7 +1935,7 @@
 
 	sprintf(currentMedia ,"%s/%s", HOME_PATH, PCL);
 	syslog(LOG_DAEMON|LOG_INFO, "%s", currentMedia);
-	if((datafile = open64(currentMedia, O_RDWR)) == -1) {
+	if((datafile = open(currentMedia, O_RDWR)) == -1) {
 		syslog(LOG_DAEMON|LOG_ERR, "%s: open failed, %m", currentMedia);
 		return 0; 	// Unsuccessful load
 	}
@@ -1961,10 +1961,11 @@
 		return 0;	// Unsuccessful load
 	}
 	// FIXME: Need better validation checking here !!
-	if(c_pos.next_blk != 1128) {
+	// 1128 for 32bit systems and 1144 for 64bit systems ???
+	if(c_pos.next_blk != 1144) {
 		syslog(LOG_DAEMON|LOG_ERR,
 			"MAM size incorrect, load failed"
-			" - Expected size: 1128, size found: %lld",
+			" - Expected size: 1144, size found: %ld",
 					c_pos.next_blk);
 		close(datafile);
 		return 0;	// Unsuccessful load
@@ -1985,7 +1986,7 @@
 	}
 
 	max_tape_capacity = (loff_t)c_pos.blk_size * (loff_t)1048576;
-	syslog(LOG_DAEMON|LOG_INFO, "Tape capacity: %lld", max_tape_capacity);
+	syslog(LOG_DAEMON|LOG_INFO, "Tape capacity: %ld", max_tape_capacity);
 
 	mam.record_dirty = 1;
 	// Increment load count
